%==========================================================================
%                      Travis Moleski/Rhett Huston
%
%                     FILE CREATION DATE: 03/02/2023
%
%                              lidar_overlayer.m
%
% This program looks at a ROSBAG generated by the Ohio University van and
% creates a point cloud, overlaying it with the routing_map and sim_map
% data.
%
% WIP
%
%==========================================================================

%% Clear & Setup Workspaces

clc; 
clear; 
close all;
format compact

%% Options

% Where is the location of the rosbag
bag_file_loc    = '/media/autobuntu/chonk/chonk/git_repos/test_rosbag_reader/02_21_2023_ridges_outer_loop.bag';

% Trim the data based on distance
dist_trim_bool  = 0;
min_dist        = 2;
max_dist        = 20;

% Trim the data based on channel
ring_trim_bool  = 1;
ring_min        = 5;
ring_max        = 0;
% ring_min      = 31; % higher pointed lazer - max 31
% ring_max      = 0; % lower pointed lazer - min 0

% Route & sim : Load .txt % ohio_athens_blue_v1 % ohio_ridges_v2
import_route    = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/Raw_Routes/ohio_ridges_v2/routing_map.txt';
import_sim      = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/Raw_Routes/ohio_ridges_v2/sim_map.txt';

% Van gps data: Load .csv file
% import_gps      = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/blue_route_02_23_15.bag_bestpos_AAAAAAAAAAAAAAAAAAAAAAAAA.csv';

% blue route
% import_gps = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/blue_route_03_06_2023/blue_route_03_06_2023_p1_bestpos.csv';
% import_gps = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/blue_route_03_06_2023/blue_route_csv.csv';

% ridges_outer
import_gps_1 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/outer_loop/2023-03-06-13-18-53_bestpos.csv';
% import_gps_2 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/outer_loop/2023-03-06-13-21-57_bestpos.csv';
% import_gps_3 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/outer_loop/2023-03-06-13-24-50_bestpos.csv';

% ridges_inner
% import_gps_1 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/inner_loop/2023-03-06-13-28-17_bestpos.csv';
% import_gps_2 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/inner_loop/2023-03-06-13-31-06_bestpos.csv';
% import_gps_3 = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/ridges_03_06_2023/inner_loop/2023-03-06-13-33-48_bestpos.csv';

% Export dir
export_dir = '/media/autobuntu/chonk/chonk/git_repos/Van_Apollo_GPS_Handler/MATLAB_Scripts/03_06_2023_ROSBAGS/03_06_2023_figs/Ridges_All_Drives';

% Export Name
export_name = 'Ridges_All_OUTER';

% Save stuffs? 1 = yes, 0 = no
save_data       = 0;
save_figs       = 0;

% Reading from csv generated from a rosbag or cyberbag?
cyberbag_bool   = 0;
rosbag_bool     = 1;

%% Variable Initiation

% Setting the physical distances
LiDAR_Ref_Frame             = [0; 1.584; 1.444];
IMU_Ref_Frame               = [0; 0.336; -0.046];

% Array Inits
matched_gps_store = [];
route_data_array = [];
time_store  = [];
x_route     = [];
y_route     = [];
x_sim       = [];
y_sim       = [];
lat_all     = [];
lon_all     = [];

% Correction frame:         LiDAR_Ref_Frame - IMU_Ref_Frame [Y X Z]
gps_to_lidar_diff           = [(LiDAR_Ref_Frame(1) - IMU_Ref_Frame(1)), (LiDAR_Ref_Frame(2) - IMU_Ref_Frame(2)), (LiDAR_Ref_Frame(3) - IMU_Ref_Frame(3))]; 

% Initilizing counts for scanning the routing & sim .txt files line by line
zero_count = 0; 
one_count = 0;
route_count  = 1;
sim_count   = 1;
lane_count  = 1;

% Projections for the x,y to lat,lon
% proj        = projcrs(6346);
% proj        = projcrs(26917);
% proj = projcrs(3747);
proj = projcrs(3724);
% proj = projcrs();

% Export location
% [~,export_name,~] = fileparts(export_dir);
mkdir(export_dir)
addpath(export_dir)

% Sim map list to export. Probably don't change this, mmhmm?
no_no_list = ["bottom:" "left_boundary" "right_boundary" "boundary" "boundary_type" "central_curve" "crosswalk" "crosswalk_overlap_info" "curve" "date:" "direction:" "district:" "edge" "end_s:" "header" "id" "id:" "is_merge:" "junction" "junction_id" "junction_overlap_info" "lane" "lane_id" "lane_overlap_info" "left:" "left_neighbor_forward_lane_id" "left_neighbor_reverse_lane_id" "length:""location" "object" "outer_polygon" "overlap" "overlap_id" "polygon" "predecessor_id" "proj:" "projection" "rev_major:" "rev_minor:" "right:" "right_neighbor_forward_lane_id" "right_neighbor_reverse_lane_id" "road" "s:" "section" "segment" "signal" "signal_overlap_info" "speed_limit:" "start_position" "start_s:" "stop_line" "stop_sign" "stop_sign_overlap_info" "subsignal" "successor_id" "top:" "turn:" "type:" "types:" "vendor:" "version:" "virtual:" "yield" "yield_sign_overlap_info" "z:" "}"];
yes_yes_list = [ "line_segment" ];

%% Opening sim/route files and importing into workspace

routingmap  = import_routing_map_txt(import_route);
simmap      = import_routing_map_txt(import_sim);
route_size  = size(routingmap);
sim_size    = size(simmap);

van_gps_1         = readtable(import_gps_1);
% van_gps_2         = readtable(import_gps_2);
% van_gps_3         = readtable(import_gps_3);

%% Opening van files and importing into workspace

if cyberbag_bool % Using cyberbags
    
    lat_van_1         = table2array(van_gps_1(:,9));
    lon_van_1         = table2array(van_gps_1(:,10));
    alt_van_1         = table2array(van_gps_1(:,11));
    sat_van_1         = table2array(van_gps_1(:,20));

elseif rosbag_bool % Using rosbags
    
    lat_van_1         = table2array(van_gps_1(:,3));
    lon_van_1         = table2array(van_gps_1(:,4));
    alt_van_1         = table2array(van_gps_1(:,5));
    sat_van_1         = table2array(van_gps_1(:,12));
%     
%     lat_van_2         = table2array(van_gps_2(:,3));
%     lon_van_2         = table2array(van_gps_2(:,4));
%     alt_van_2         = table2array(van_gps_2(:,5));
%     sat_van_2         = table2array(van_gps_2(:,12));
%     
%     lat_van_3         = table2array(van_gps_3(:,3));
%     lon_van_3         = table2array(van_gps_3(:,4));
%     alt_van_3         = table2array(van_gps_3(:,5));
%     sat_van_3         = table2array(van_gps_3(:,12));
%     
end


%% Scanning for Sim Map Data

% LONGITUDE = UP/DOWN == Y; LATITUDE = LEFT/RIGHT = X

for sim_line = 1:1:sim_size(1)
    
    if contains(simmap(sim_line,1), no_no_list)
        
        zero_count = zero_count + 1;
        
    end
        
    if contains(simmap(sim_line,1), yes_yes_list)
        
        while true
            
            sim_line = sim_line + 1;
            
            if contains(simmap(sim_line,1), 'x:') == 1

                x_sim = [x_sim; str2double(simmap(sim_line,2))];
                
            elseif contains(simmap(sim_line,1), 'y:') == 1
                
                y_sim = [y_sim; str2double(simmap(sim_line,2))];

            end
            
            if simmap(sim_line - 1, 1) == simmap(sim_line, 1)

                [lat_sim, lon_sim] = projinv(proj, x_sim, y_sim);
                
                sim_segment_latlon{sim_count} = [lat_sim, lon_sim];
                
                sim_count = sim_count + 1;
            
                x_sim = []; y_sim = []; 
                
                break
                
            end % the next line == the previous line
        
        end % until the next line == the previous line
        
    end % if the line contains something that we want to keep
    
end % for each line in the sim file

%% Scanning for route map data

% Looks for each routing map node & inserts to cell
for line = 1:1:route_size(1)

    % If line contains x
    if contains(routingmap(line,1), 'x:')
        
        x_route = [x_route; str2double(routingmap(line,2))];
        
    elseif contains(routingmap(line,1), 'y:') % If line contains y
        
        y_route = [y_route; str2double(routingmap(line,2))];
        
    elseif contains(routingmap(line,1), 'start_position')
        
        line = line + 3;
    
    elseif contains(routingmap(line,1), 'node') % If line contains node
        
        [lat, lon] = projinv(proj, x_route, y_route);
        
        segment_latlon{lane_count} = [lat,lon];
        
        lane_count = lane_count + 1;
        
        x_route = [];
        y_route = [];
        
    end
    
end

%% Converting to single array to find the origin. 
for seg_idx = 1:1:length(segment_latlon)

    if ~isempty(segment_latlon{seg_idx})

        route_data_array = [route_data_array; segment_latlon{seg_idx}(1:end-1,1), segment_latlon{seg_idx}(1:end-1,2)];

    end

end

%% Loading the ROSBAG

disp('Loading Bag...')

% Load the rosbag into the workspace
bag =  rosbag(bag_file_loc);

% Topics
topics = bag.AvailableTopics;
          
lidar_topic = select(bag,'Topic','velodyne_points');
lidar_msgs = readMessages(lidar_topic, 'DataFormat', 'struct');

% NOTE: /gps/gps is the same as the Novatel's best pose topic: it is rtk
% corrected!
gps_topic = select(bag,'Topic','/gps/gps');
gps_msgs = readMessages(gps_topic, 'DataFormat', 'struct');

% Setting the length of the loop and alocating memory
cloud_break                 = length(lidar_msgs);
gps_pos_store               = zeros(cloud_break,3);
lidar_pos_store             = gps_pos_store;

disp('Bag Loaded!')

%% Timestamps

% Matching timestamps
[indexes, fromTimes, toTimes, diffs] = matchTimestamps(lidar_msgs, gps_msgs);

%Find which GPS message matches the first scan
matchedLidar                = lidar_msgs{1};
matchedGps_init             = gps_msgs{indexes(1)};

%% Initilizing the starting point

% Select reference point as first GPS reading (local)
origin = [matchedGps_init.Latitude, matchedGps_init.Longitude, matchedGps_init.Altitude];
[xEast_init, yNorth_init, zUp_init] = latlon2local(matchedGps_init.Latitude, matchedGps_init.Longitude, matchedGps_init.Altitude, origin);

%%  CONVERT TO LIDAR FRAME:

% Setting the offset from the gps orientation to the lidar
% takes gps emu to local frame of lidar
gps2lidar = [ cosd(90) sind(90) 0;
             -sind(90) cosd(90) 0;
             0       0          1]; 
         
% Setting the (gps_to_lidar_diff) offset from the lidar offset to the gps
LidarOffset2gps = [ cosd(90) -sind(90)  0;
              sind(90)  cosd(90)   0;
              0        0           1]; 

%% Doing the data

fprintf('Max time delta is %f sec \n',max(abs(diffs)));

h = waitbar(0, "Cartographing...");

for cloud = 1:length(lidar_msgs)
    
    % Timerz
    tStart = tic;

    % Var Init
    gps_xyz_cloud = [];
    
    % Reading the current point cloud and matched gps coord
    current_cloud               = lidar_msgs{cloud};
    matched_stamp               = gps_msgs{indexes(cloud)};
    
    % Converting the gps coord to xyz (m)
%     [xEast, yNorth, zUp]        = latlon2local(matched_stamp.Latitude, matched_stamp.Longitude, matched_stamp.Altitude, origin);
    [xEast, yNorth, zUp]        = latlon2local(matched_stamp.Latitude, matched_stamp.Longitude, matched_stamp.Altitude, origin);

    % Matched GPS Store
    matched_gps_store{cloud}    = [xEast, yNorth, zUp];
    
    % Grabbing the angles
    roll                        = matched_stamp.Roll;
    pitch                       = matched_stamp.Pitch;
    yaw                         = matched_stamp.Track+180;
    
    % Creating the rotation matrix
    rotate_update               = rotz(90-yaw)*roty(roll)*rotx(pitch);
     
    % Offset the gps coord by the current orientation (in this case, initial) 
    % Converts the ground truth to lidar frame
    groundTruthTrajectory       = [xEast, yNorth, zUp] * gps2lidar ;
    
    % Setting the updated difference between the lidar and gps coordiate and
    % orientation
    % Converts the offsett to the lidar frame
    gps_to_lidar_diff_update    = gps_to_lidar_diff * LidarOffset2gps * rotate_update;

    % Offset the gps coord by the current orientation (in this case, initial) 
    % Converts the ground truth to lidar frame
%     groundTruthTrajectory       = groundTruthTrajectory;
    
    % Rotating the offset and adding them together
    LidarxEast                  = groundTruthTrajectory(1)  + gps_to_lidar_diff_update(1);
    LidaryNorth                 = groundTruthTrajectory(2)  + gps_to_lidar_diff_update(2);
    LidarzUp                    = groundTruthTrajectory(3)  + gps_to_lidar_diff_update(3);
    
    % Making the vector of ^^^
    lidarTrajectory             = [LidarxEast, LidaryNorth, LidarzUp];
    
    % Reading the current cloud for xyz, intensity, and ring (channel) values
    xyz_cloud                   = rosReadXYZ(current_cloud);
    intensities                 = rosReadField(current_cloud, 'intensity');
    ring                        = rosReadField(current_cloud, 'ring');
    xyz_cloud(:,4)              = intensities;
    xyz_cloud(:,5)              = ring;
    
    % Here are options for trimming data ~~~~~~~
    
    % Eliminate points based on channel
    if ring_trim_bool
        xyz_cloud(xyz_cloud(:,5) < ring_max, :) = [];
        xyz_cloud(xyz_cloud(:,5) > ring_min, :) = [];
    end
    
    % Eliminate points based on distance
    if dist_trim_bool
        xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) <= min_dist, :) = [];
        xyz_cloud(sqrt(xyz_cloud(:,1).^2 + xyz_cloud(:,2).^2 + xyz_cloud(:,3).^2) >= max_dist, :) = [];
    end
    
    % Eliminiating infs and nans from the xyz data - there may be a way to
    xyz_cloud                   = xyz_cloud( ~any( isnan(xyz_cloud) | isinf(xyz_cloud), 2),:);
    
    % Sort rows based on ring
    xyz_cloud = sortrows(xyz_cloud,5);
    
%     xyz_cloud(:,1:3) = xyz_cloud(:,1:3) * rotz(90);
    
    % Transforming the point cloud
    tform                       = rigid3d(rotate_update, [lidarTrajectory(1) lidarTrajectory(2) lidarTrajectory(3)]);
    
    % Creating the point cloud object3
    pointClouXYZI_curr          = pointCloud([xyz_cloud(:,1), xyz_cloud(:,2), xyz_cloud(:,3)], 'Intensity',  xyz_cloud(:,4));
    pointClouXYZI_curr          = pctransform(pointClouXYZI_curr, tform);
    
    % Convert xyz to lat lon height 
    % LONGITUDE = UP/DOWN == Y; LATITUDE = LEFT/RIGHT = X
    [lat,lon,~] = local2latlon(pointClouXYZI_curr.Location(:,1),pointClouXYZI_curr.Location(:,2),pointClouXYZI_curr.Location(:,3), [matched_stamp.Latitude, matched_stamp.Longitude, matched_stamp.Altitude]);
%     
    gps_xyz_cloud(:,1) = lat; % x
    gps_xyz_cloud(:,2) = lon; % y
    gps_xyz_cloud(:,3) = xyz_cloud(:,3); % z
    gps_xyz_cloud(:,4) = xyz_cloud(:,4); % i

    % This fixes the orientation. Maybe has to do with the way
    % latlon2local works or something but I'm too lazy to figure out
    % exactly why things are flipped. Anyways this fixes the orientation
    % and I'm not thinking any harder about it.
%     gps_xyz_cloud(:,1:3) = gps_xyz_cloud(:,1:3) * rotz(90);

    gps_pointCloudXYZI_curr = pointCloud([gps_xyz_cloud(:,1), gps_xyz_cloud(:,2), gps_xyz_cloud(:,3)], 'Intensity',  gps_xyz_cloud(:,4));
    
%     gps_pos_store(cloud,:)      = groundTruthTrajectory;
%     lidar_pos_store(cloud,:)    = lidarTrajectory;
    
    % Storing local coords
    pointCloudList{cloud}       = pointClouXYZI_curr;
    
    gps_pointCloudList{cloud} = gps_pointCloudXYZI_curr;
    
    %% Time to Completion Estimation
    tEnd = toc(tStart);
    time_store = [time_store; tEnd];
    time_avg = mean(time_store);
    est_time_to_complete = (time_avg * (cloud_break - cloud));
    
    %% Waitbar
    
    waitbar(cloud/cloud_break,h,sprintf('Cloud %d out of %d, ~ %0.1f sec left',cloud, cloud_break, est_time_to_complete))
    
end

delete(h)

%% Compiling the map

disp("Making the gps map, sire......")
pointCloudList = pccat([pointCloudList{:}]);
% gps_pointCloudList = pccat([gps_pointCloudList{:}]);

%% Finding closest routing map location to origin

route_match_idx = knnsearch(route_data_array, origin(:,1:2));
route_sim_origin = route_data_array(route_match_idx,:);

%% Re-evaulate the sim-map based on origin

for sim_line = 1:1:sim_size(1)
    
    if contains(simmap(sim_line,1), no_no_list)
        
        zero_count = zero_count + 1;
        
    end
        
    if contains(simmap(sim_line,1), yes_yes_list)
        
        while true
            
            sim_line = sim_line + 1;
            
            if contains(simmap(sim_line,1), 'x:') == 1

                x_sim = [x_sim; str2double(simmap(sim_line,2))];
                
            elseif contains(simmap(sim_line,1), 'y:') == 1
                
                y_sim = [y_sim; str2double(simmap(sim_line,2))];

            end
            
            if simmap(sim_line - 1, 1) == simmap(sim_line, 1)

                [lat_sim, lon_sim] = projinv(proj, x_sim, y_sim);
                
                [sim_x, sim_y, ~] = latlon2local(lat_sim, lon_sim, zeros(length(lat_sim),1), [route_sim_origin 0]);
                                
                sim_segment_xy{sim_count} = [lat_sim, lon_sim];
                
                sim_count = sim_count + 1;
            
                x_sim = []; y_sim = []; 
                
                break
                
            end % the next line == the previous line
        
        end % until the next line == the previous line
        
    end % if the line contains something that we want to keep
    
end % for each line in the sim file

%% Re-evaulate the route_map based on origin

% Looks for each routing map node & inserts to cell
for line = 1:1:route_size(1)

    % If line contains x
    if contains(routingmap(line,1), 'x:')
        
        x_route = [x_route; str2double(routingmap(line,2))];
        
    elseif contains(routingmap(line,1), 'y:') % If line contains y
        
        y_route = [y_route; str2double(routingmap(line,2))];
        
    elseif contains(routingmap(line,1), 'start_position')
        
        line = line + 3;
    
    elseif contains(routingmap(line,1), 'node') % If line contains node
        
        [lat, lon] = projinv(proj, x_route, y_route);
        
        [route_x, route_y, ~] = latlon2local(lat, lon, zeros(length(lat),1), [route_sim_origin 0]);
        
        % LOL
        route_x = route_x - 2;
        route_y = route_y + 1;
        
        segment_xy{lane_count} = [route_x,route_y];
        
        lane_count = lane_count + 1;
        
        x_route = [];
        y_route = [];
        
    end
    
end

%% Correcting point cloud ( just rotated 90 degrees ) 

test_pc = pctransform(pointCloudList, rigid3d((rotz(90)), [0 0 0]));


%% Plotting the corrected point cloud

figuretest = figure('DefaultAxesFontSize', 14,'WindowState','maximized','Color',[1 1 1]);
pcshow(test_pc)
colormap(jet);
figuretest.Color = 'white';
set(gca, 'color', [1 1 1], 'XColor','k', 'YColor','k')
view([0 0 90])

%% Plotting the route

hold all

% Plots all segments as lines
for seg_idx = 1:1:length(segment_xy)

    if ~isempty(segment_xy{seg_idx})

        plot(segment_xy{seg_idx}(1:end-1,1), segment_xy{seg_idx}(1:end-1,2), 'r--', 'LineWidth', 2.5)   

    end

end


%% Displaying the gps map

% Create figure
figure1 = figure('DefaultAxesFontSize', 14);
colormap(jet);

% Create axes
axes1 = axes('Tag','PointCloud','Parent',figure1);
hold(axes1,'on');

hold on

% % Plotting the line between the lidar and gps
% for point = 1:length(lidar_pos_store)
%     
%     plot3([lidar_pos_store(point,1) gps_pos_store(point,1)],...
%           [lidar_pos_store(point,2) gps_pos_store(point,2)],...
%           [lidar_pos_store(point,3) gps_pos_store(point,3)],...
%           'linewidth',3)
%       
% end

% Plotting the lidar and gps points
% scatter3(gps_pos_store(1,1),gps_pos_store(1,2),gps_pos_store(1,3),420,'^','MarkerFaceColor','yellow')
% scatter3(gps_pos_store(end,1),gps_pos_store(end,2),gps_pos_store(end,3),420,'^','MarkerFaceColor','blue')
% scatter3(gps_pos_store(:,1),gps_pos_store(:,2),gps_pos_store(:,3),50,'^','MarkerFaceColor','magenta')
% scatter3(lidar_pos_store(:,1),lidar_pos_store(:,2),lidar_pos_store(:,3),50,'^','MarkerFaceColor','cyan')

% Plotting the point cloud
pcshow(pointCloudList);
figure1.Color = 'white';
set(gca, 'color', [1 1 1])
% set(gfa, 'color', [1 1 1])
% scatter3(gps_pointCloudList.Location(:,1), gps_pointCloudList.Location(:,2), gps_pointCloudList.Location(:,3), 'Marker', '.')
axis equal
view([0 0 90])

%% Save the PCD
% 
% save_ans = questdlg('Save pcd?', 'Save pcd?', 'Yes', 'No', 'No');
% 
% switch save_ans
%     
%     case 'Yes'
%         
%         name_ans        = inputdlg({'Enter Filename:'}, 'Filename', [1 35], {'pcd.pcd'});
%         name_ans        = name_ans{:};
%                 
%         export_dir      = uigetdir();
%         PCDFileName     = fullfile(export_dir, name_ans);
%         
%         pcwrite(pointCloudList,PCDFileName)
%         
%     case 'No'
%         
%         warning('WILL NOT SAVE THE PCD!')
%         
% end

%% End Program 

% web('https://www.youtube.com/watch?v=DPBvMsT3prg&ab_channel=AdesRizaTV')

disp('End Program!')

