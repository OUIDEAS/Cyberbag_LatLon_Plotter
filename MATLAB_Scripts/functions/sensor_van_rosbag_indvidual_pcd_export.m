%==========================================================================
%                               Rhett Huston
%
%                      FILE CREATION DATE: 09/15/2021
%
%                         ROSBAG HANDLER: Velodyne
%
% This is a quick set of programs that will extract lidar data from a 
% rosbag generated by the van The primary purpose of this is to begin work 
% on creating a road surface detection algorithm for use in my thesis.
% NOTE: WORKS WITH 2020b MATLAB OR LATER!!!
%==========================================================================

function sensor_van_rosbag_indvidual_pcd_export(bag_init,RPM,pcd_export_file_path,device_model,num_channels)
    
    % INITIATION
    
    % Timing
    tic
    
    % Converting the RPM into Hz then finding dT for each revolution. This
    % will hopefully make a point cloud with one full revolution.
    dT                      = 1 / (RPM / 60);
    
    % Player
    player_bool             = 0;
    
    % Velodyne
    velodyne_packets_topic	= '/velodyne_packets';
%     velodyne_points_topic	= '/velodyne_points';
    
    % Selecting the bag
    velodyne_packets_bag    = select(bag_init, 'Topic', velodyne_packets_topic);
%     velodyne_points_bag     = select(bag_init, 'Topic', velodyne_points_topic);
    
    % Creating Structure
    velodyne_packets_struct = readMessages(velodyne_packets_bag,'DataFormat','struct');
%     velodyne_points_struct  = readMessages(velodyne_points_bag,'DataFormat','struct');
    
    % Timing
    toc
    disp('Structure Creation Completed.')
    
    % Warning for length of process
    if length(velodyne_packets_struct) > 10
        
        fprintf("\n WARNING: %i point clouds will be created (takes time)\n", length(velodyne_packets_struct))
        
    end
    
    %% Allocating memory for the matrices: Needs length of each sweep.
    
    % Reading the velodyne stuffs
    veloReader_packets      = velodyneROSMessageReader(velodyne_packets_struct,device_model);
    
    % Extracting Point Clouds
    timeDuration_packets    = veloReader_packets.StartTime;
                   
    % Read first point cloud recorded
    ptCloudObj_packets      = readFrame(veloReader_packets, timeDuration_packets);
            
    % Access Location Data
    ptCloudLoc_packets      = ptCloudObj_packets.Location;
    
    % Checking Length
    memory_array_xyzi       = double(zeros(1, length(ptCloudLoc_packets(:,:,1)) * num_channels));
    memory_array_pt_pack    = double(zeros(32, length(ptCloudLoc_packets(:,:,1)) * num_channels));
    memory_array_XYZI_TOT   = double(zeros(length(velodyne_packets_struct),4));
    
    % Allocation
    x_append                = memory_array_xyzi;
    y_append                = memory_array_xyzi;
    z_append                = memory_array_xyzi;
    int_append              = memory_array_xyzi;
    ptCloudLoc_packets      = memory_array_pt_pack;
    XYZI_TOT                = memory_array_XYZI_TOT;
    
    timing                  = zeros(1,length(velodyne_packets_struct));
    
    
    %% Loop
    % Timing
%     tic
    
    % Exporting PCDs
    for i = 1:length(velodyne_packets_struct)
        
        veloReader_packets      = velodyneROSMessageReader(velodyne_packets_struct,device_model);
        % Timing
        tic
    
        dT_loop                 = dT * i;
            
        % Extracting Point Clouds
%       timeDuration_points      = veloReader_points.StartTime + seconds(dT);
        timeDuration_packets    = veloReader_packets.StartTime + seconds(dT_loop);
                   
        % Read first point cloud recorded
%       ptCloudObj_points        = readFrame(veloReader_points, timeDuration_packets);
        ptCloudObj_packets      = readFrame(veloReader_packets, timeDuration_packets);
            
        % Access Location Data
    %     ptCloudLoc_points        = ptCloudObj_points.Location;
        ptCloudLoc_packets      = ptCloudObj_packets.Location;
        
        % Access Intensity Data
        ptCloudInt_packets      = ptCloudObj_packets.Intensity;
        
        % Extracting data
        for j = 1:32
            
            x                       = ptCloudLoc_packets(j,:,1);
            y                       = ptCloudLoc_packets(j,:,2);
            z                       = ptCloudLoc_packets(j,:,3);
            int                     = ptCloudInt_packets(j,:);
            
            x_append                = [x_append x];
            y_append                = [y_append y];
            z_append                = [z_append z];
            int_append              = [int_append int];
            
        end % Extracting data
        
        XYZI_TOT                = [x_append' y_append' z_append'];
        
        pc                      = pointCloud(XYZI_TOT, 'Intensity', int_append');
        
%         pcshow(pc)
        
        %Creates pcd file name
        n_strPadded             = sprintf('%08d', i);
        pcdFileName             = strcat(pcd_export_file_path, '/', n_strPadded, '.pcd');

        %Writes to a pcd file
        pcwrite(pc, pcdFileName);
        
        fprintf("\n Progress: %i / %i \n", i, length(velodyne_packets_struct))
        
        % Resetting the arrays
        x_append                = memory_array_xyzi;
        y_append                = memory_array_xyzi;
        z_append                = memory_array_xyzi;
        int_append              = memory_array_xyzi;
        
        % Timing
        timing(i)               = toc;
        
    end  % Exporting PCD
    
    fprintf("\n     Average Time: %d\n", mean(timing(1:i)))

    % Plotting the time
    figure
    plot(timing(1:i), 'LineWidth', 3)
    xlimits = [0 length(velodyne_packets_struct)];
    xlabel = 'pcd number';
    ylabel = 'Time (s)';
    
    %% Player
    
    if player_bool == 1
        figure
        
        xlimits = [-60 60];
        ylimits = [-60 60];
        zlimits = [-20 20];

        player = pcplayer(xlimits, ylimits, zlimits);

        xlabel(player.Axes, "X (m)");
        ylabel(player.Axes, "Y (m)");
        zlabel(player.Axes, "Z (m)");
%         view(player.view, [0 0 90]);

        veloReader_packets.CurrentTime = veloReader_packets.StartTime + seconds(dT);
        
        % Viewer handler
        while(hasFrame(veloReader_packets) && isOpen(player))% && (veloReader_packets.CurrentTime < veloReader_packets.StartTime + seconds(20)))
            
            ptCloudObj_packets      = readFrame(veloReader_packets);
            
            view(player, ptCloudObj_packets.Location, ptCloudObj_packets.Intensity);

            % Real Time Playback (if commented out, renders as fast as the
            % computer can handel)
            % pause(dT);

        end % While loop handling the viewer
    
    end
    
    %%
    
    fprintf("\n END OF VELODYNE - OFFICIAL YAY MAY BE EXCLAIMED\n\n\n")

end

